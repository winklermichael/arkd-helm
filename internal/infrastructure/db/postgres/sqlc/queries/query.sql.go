// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const insertVtxoCommitmentTxid = `-- name: InsertVtxoCommitmentTxid :exec
INSERT INTO vtxo_commitment_txid (vtxo_txid, vtxo_vout, commitment_txid)
VALUES ($1, $2, $3)
`

type InsertVtxoCommitmentTxidParams struct {
	VtxoTxid       string
	VtxoVout       int32
	CommitmentTxid string
}

func (q *Queries) InsertVtxoCommitmentTxid(ctx context.Context, arg InsertVtxoCommitmentTxidParams) error {
	_, err := q.db.ExecContext(ctx, insertVtxoCommitmentTxid, arg.VtxoTxid, arg.VtxoVout, arg.CommitmentTxid)
	return err
}

const selectAllRoundIds = `-- name: SelectAllRoundIds :many
SELECT id FROM round
`

func (q *Queries) SelectAllRoundIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectAllRoundIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllVtxos = `-- name: SelectAllVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw
`

type SelectAllVtxosRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectAllVtxos(ctx context.Context) ([]SelectAllVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllVtxosRow
	for rows.Next() {
		var i SelectAllVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectLatestMarketHour = `-- name: SelectLatestMarketHour :one
SELECT id, start_time, end_time, period, round_interval, updated_at FROM market_hour ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) SelectLatestMarketHour(ctx context.Context) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, selectLatestMarketHour)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const selectNotUnrolledVtxos = `-- name: SelectNotUnrolledVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE unrolled = false
`

type SelectNotUnrolledVtxosRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectNotUnrolledVtxos(ctx context.Context) ([]SelectNotUnrolledVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotUnrolledVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotUnrolledVtxosRow
	for rows.Next() {
		var i SelectNotUnrolledVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotUnrolledVtxosWithPubkey = `-- name: SelectNotUnrolledVtxosWithPubkey :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE unrolled = false AND pubkey = $1
`

type SelectNotUnrolledVtxosWithPubkeyRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectNotUnrolledVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectNotUnrolledVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotUnrolledVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotUnrolledVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectNotUnrolledVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectOffchainTx = `-- name: SelectOffchainTx :many
SELECT  offchain_tx_vw.txid, offchain_tx_vw.tx, offchain_tx_vw.starting_timestamp, offchain_tx_vw.ending_timestamp, offchain_tx_vw.expiry_timestamp, offchain_tx_vw.fail_reason, offchain_tx_vw.stage_code, offchain_tx_vw.checkpoint_txid, offchain_tx_vw.checkpoint_tx, offchain_tx_vw.commitment_txid, offchain_tx_vw.is_root_commitment_txid, offchain_tx_vw.offchain_txid FROM offchain_tx_vw WHERE txid = $1
`

type SelectOffchainTxRow struct {
	OffchainTxVw OffchainTxVw
}

func (q *Queries) SelectOffchainTx(ctx context.Context, txid string) ([]SelectOffchainTxRow, error) {
	rows, err := q.db.QueryContext(ctx, selectOffchainTx, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectOffchainTxRow
	for rows.Next() {
		var i SelectOffchainTxRow
		if err := rows.Scan(
			&i.OffchainTxVw.Txid,
			&i.OffchainTxVw.Tx,
			&i.OffchainTxVw.StartingTimestamp,
			&i.OffchainTxVw.EndingTimestamp,
			&i.OffchainTxVw.ExpiryTimestamp,
			&i.OffchainTxVw.FailReason,
			&i.OffchainTxVw.StageCode,
			&i.OffchainTxVw.CheckpointTxid,
			&i.OffchainTxVw.CheckpointTx,
			&i.OffchainTxVw.CommitmentTxid,
			&i.OffchainTxVw.IsRootCommitmentTxid,
			&i.OffchainTxVw.OffchainTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundConnectors = `-- name: SelectRoundConnectors :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t WHERE t.round_id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = $1 AND type = 'commitment'
) AND t.type = 'connector'
`

func (q *Queries) SelectRoundConnectors(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundConnectors, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundForfeitTxs = `-- name: SelectRoundForfeitTxs :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t WHERE t.round_id IN (
    SELECT tx.round_id FROM tx WHERE tx.txid = $1 AND type = 'commitment'
) AND t.type = 'forfeit'
`

func (q *Queries) SelectRoundForfeitTxs(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundForfeitTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInTimeRange = `-- name: SelectRoundIdsInTimeRange :many
SELECT id FROM round WHERE starting_timestamp > $1 AND starting_timestamp < $2
`

type SelectRoundIdsInTimeRangeParams struct {
	StartTs int64
	EndTs   int64
}

func (q *Queries) SelectRoundIdsInTimeRange(ctx context.Context, arg SelectRoundIdsInTimeRangeParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInTimeRange, arg.StartTs, arg.EndTs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundStats = `-- name: SelectRoundStats :one
SELECT
    r.swept,
    r.starting_timestamp,
    r.ending_timestamp,
    (
        SELECT COALESCE(SUM(ii.amount), 0)::bigint FROM intent_with_inputs_vw ii WHERE ii.round_id = r.id
    ) AS total_forfeit_amount,
    (
        SELECT COALESCE(COUNT(ii.txid), 0)::bigint FROM intent_with_inputs_vw ii WHERE ii.round_id = r.id
    ) AS total_input_vtxos,
    (
        SELECT COALESCE(SUM(ir.amount), 0)::bigint FROM intent_with_receivers_vw ir
        WHERE ir.round_id = r.id AND COALESCE(ir.onchain_address, '') = ''
    ) AS total_batch_amount,
    (
        SELECT COUNT(*) FROM intent_with_receivers_vw ir WHERE ir.round_id = r.id AND COALESCE(ir.onchain_address, '') = ''
    ) AS total_output_vtxos,
    (
        SELECT MAX(v.expires_at) FROM vtxo_vw v WHERE v.commitment_txid = r.txid
    ) AS expires_at
FROM round_with_commitment_tx_vw r
WHERE r.txid = $1
`

type SelectRoundStatsRow struct {
	Swept              bool
	StartingTimestamp  int64
	EndingTimestamp    int64
	TotalForfeitAmount int64
	TotalInputVtxos    int64
	TotalBatchAmount   int64
	TotalOutputVtxos   int64
	ExpiresAt          interface{}
}

func (q *Queries) SelectRoundStats(ctx context.Context, txid string) (SelectRoundStatsRow, error) {
	row := q.db.QueryRowContext(ctx, selectRoundStats, txid)
	var i SelectRoundStatsRow
	err := row.Scan(
		&i.Swept,
		&i.StartingTimestamp,
		&i.EndingTimestamp,
		&i.TotalForfeitAmount,
		&i.TotalInputVtxos,
		&i.TotalBatchAmount,
		&i.TotalOutputVtxos,
		&i.ExpiresAt,
	)
	return i, err
}

const selectRoundVtxoTree = `-- name: SelectRoundVtxoTree :many
SELECT txid, tx, round_id, type, position, children FROM tx WHERE round_id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = $1 AND type = 'commitment'
) AND type = 'tree'
`

func (q *Queries) SelectRoundVtxoTree(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundVtxoTree, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundVtxoTreeLeaves = `-- name: SelectRoundVtxoTreeLeaves :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE commitment_txid = $1 AND preconfirmed = false
`

type SelectRoundVtxoTreeLeavesRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectRoundVtxoTreeLeaves(ctx context.Context, commitmentTxid string) ([]SelectRoundVtxoTreeLeavesRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundVtxoTreeLeaves, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundVtxoTreeLeavesRow
	for rows.Next() {
		var i SelectRoundVtxoTreeLeavesRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithId = `-- name: SelectRoundWithId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration, round.fail_reason,
    round_intents_vw.id, round_intents_vw.round_id, round_intents_vw.proof, round_intents_vw.message,
    round_txs_vw.txid, round_txs_vw.tx, round_txs_vw.round_id, round_txs_vw.type, round_txs_vw.position, round_txs_vw.children,
    intent_with_receivers_vw.intent_id, intent_with_receivers_vw.pubkey, intent_with_receivers_vw.onchain_address, intent_with_receivers_vw.amount, intent_with_receivers_vw.id, intent_with_receivers_vw.round_id, intent_with_receivers_vw.proof, intent_with_receivers_vw.message,
    intent_with_inputs_vw.txid, intent_with_inputs_vw.vout, intent_with_inputs_vw.pubkey, intent_with_inputs_vw.amount, intent_with_inputs_vw.expires_at, intent_with_inputs_vw.created_at, intent_with_inputs_vw.commitment_txid, intent_with_inputs_vw.spent_by, intent_with_inputs_vw.spent, intent_with_inputs_vw.unrolled, intent_with_inputs_vw.swept, intent_with_inputs_vw.preconfirmed, intent_with_inputs_vw.settled_by, intent_with_inputs_vw.ark_txid, intent_with_inputs_vw.intent_id, intent_with_inputs_vw.commitments, intent_with_inputs_vw.id, intent_with_inputs_vw.round_id, intent_with_inputs_vw.proof, intent_with_inputs_vw.message
FROM round
LEFT OUTER JOIN round_intents_vw ON round.id=round_intents_vw.round_id
LEFT OUTER JOIN round_txs_vw ON round.id=round_txs_vw.round_id
LEFT OUTER JOIN intent_with_receivers_vw ON round_intents_vw.id=intent_with_receivers_vw.intent_id
LEFT OUTER JOIN intent_with_inputs_vw ON round_intents_vw.id=intent_with_inputs_vw.intent_id
WHERE round.id = $1
`

type SelectRoundWithIdRow struct {
	Round                 Round
	RoundIntentsVw        RoundIntentsVw
	RoundTxsVw            RoundTxsVw
	IntentWithReceiversVw IntentWithReceiversVw
	IntentWithInputsVw    IntentWithInputsVw
}

func (q *Queries) SelectRoundWithId(ctx context.Context, id string) ([]SelectRoundWithIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithIdRow
	for rows.Next() {
		var i SelectRoundWithIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.Round.FailReason,
			&i.RoundIntentsVw.ID,
			&i.RoundIntentsVw.RoundID,
			&i.RoundIntentsVw.Proof,
			&i.RoundIntentsVw.Message,
			&i.RoundTxsVw.Txid,
			&i.RoundTxsVw.Tx,
			&i.RoundTxsVw.RoundID,
			&i.RoundTxsVw.Type,
			&i.RoundTxsVw.Position,
			&i.RoundTxsVw.Children,
			&i.IntentWithReceiversVw.IntentID,
			&i.IntentWithReceiversVw.Pubkey,
			&i.IntentWithReceiversVw.OnchainAddress,
			&i.IntentWithReceiversVw.Amount,
			&i.IntentWithReceiversVw.ID,
			&i.IntentWithReceiversVw.RoundID,
			&i.IntentWithReceiversVw.Proof,
			&i.IntentWithReceiversVw.Message,
			&i.IntentWithInputsVw.Txid,
			&i.IntentWithInputsVw.Vout,
			&i.IntentWithInputsVw.Pubkey,
			&i.IntentWithInputsVw.Amount,
			&i.IntentWithInputsVw.ExpiresAt,
			&i.IntentWithInputsVw.CreatedAt,
			&i.IntentWithInputsVw.CommitmentTxid,
			&i.IntentWithInputsVw.SpentBy,
			&i.IntentWithInputsVw.Spent,
			&i.IntentWithInputsVw.Unrolled,
			&i.IntentWithInputsVw.Swept,
			&i.IntentWithInputsVw.Preconfirmed,
			&i.IntentWithInputsVw.SettledBy,
			&i.IntentWithInputsVw.ArkTxid,
			&i.IntentWithInputsVw.IntentID,
			&i.IntentWithInputsVw.Commitments,
			&i.IntentWithInputsVw.ID,
			&i.IntentWithInputsVw.RoundID,
			&i.IntentWithInputsVw.Proof,
			&i.IntentWithInputsVw.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithTxid = `-- name: SelectRoundWithTxid :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration, round.fail_reason,
    round_intents_vw.id, round_intents_vw.round_id, round_intents_vw.proof, round_intents_vw.message,
    round_txs_vw.txid, round_txs_vw.tx, round_txs_vw.round_id, round_txs_vw.type, round_txs_vw.position, round_txs_vw.children,
    intent_with_receivers_vw.intent_id, intent_with_receivers_vw.pubkey, intent_with_receivers_vw.onchain_address, intent_with_receivers_vw.amount, intent_with_receivers_vw.id, intent_with_receivers_vw.round_id, intent_with_receivers_vw.proof, intent_with_receivers_vw.message,
    intent_with_inputs_vw.txid, intent_with_inputs_vw.vout, intent_with_inputs_vw.pubkey, intent_with_inputs_vw.amount, intent_with_inputs_vw.expires_at, intent_with_inputs_vw.created_at, intent_with_inputs_vw.commitment_txid, intent_with_inputs_vw.spent_by, intent_with_inputs_vw.spent, intent_with_inputs_vw.unrolled, intent_with_inputs_vw.swept, intent_with_inputs_vw.preconfirmed, intent_with_inputs_vw.settled_by, intent_with_inputs_vw.ark_txid, intent_with_inputs_vw.intent_id, intent_with_inputs_vw.commitments, intent_with_inputs_vw.id, intent_with_inputs_vw.round_id, intent_with_inputs_vw.proof, intent_with_inputs_vw.message
FROM round
LEFT OUTER JOIN round_intents_vw ON round.id=round_intents_vw.round_id
LEFT OUTER JOIN round_txs_vw ON round.id=round_txs_vw.round_id
LEFT OUTER JOIN intent_with_receivers_vw ON round_intents_vw.id=intent_with_receivers_vw.intent_id
LEFT OUTER JOIN intent_with_inputs_vw ON round_intents_vw.id=intent_with_inputs_vw.intent_id
WHERE round.id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = $1 AND type = 'commitment'
)
`

type SelectRoundWithTxidRow struct {
	Round                 Round
	RoundIntentsVw        RoundIntentsVw
	RoundTxsVw            RoundTxsVw
	IntentWithReceiversVw IntentWithReceiversVw
	IntentWithInputsVw    IntentWithInputsVw
}

func (q *Queries) SelectRoundWithTxid(ctx context.Context, txid string) ([]SelectRoundWithTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithTxid, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithTxidRow
	for rows.Next() {
		var i SelectRoundWithTxidRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.Round.FailReason,
			&i.RoundIntentsVw.ID,
			&i.RoundIntentsVw.RoundID,
			&i.RoundIntentsVw.Proof,
			&i.RoundIntentsVw.Message,
			&i.RoundTxsVw.Txid,
			&i.RoundTxsVw.Tx,
			&i.RoundTxsVw.RoundID,
			&i.RoundTxsVw.Type,
			&i.RoundTxsVw.Position,
			&i.RoundTxsVw.Children,
			&i.IntentWithReceiversVw.IntentID,
			&i.IntentWithReceiversVw.Pubkey,
			&i.IntentWithReceiversVw.OnchainAddress,
			&i.IntentWithReceiversVw.Amount,
			&i.IntentWithReceiversVw.ID,
			&i.IntentWithReceiversVw.RoundID,
			&i.IntentWithReceiversVw.Proof,
			&i.IntentWithReceiversVw.Message,
			&i.IntentWithInputsVw.Txid,
			&i.IntentWithInputsVw.Vout,
			&i.IntentWithInputsVw.Pubkey,
			&i.IntentWithInputsVw.Amount,
			&i.IntentWithInputsVw.ExpiresAt,
			&i.IntentWithInputsVw.CreatedAt,
			&i.IntentWithInputsVw.CommitmentTxid,
			&i.IntentWithInputsVw.SpentBy,
			&i.IntentWithInputsVw.Spent,
			&i.IntentWithInputsVw.Unrolled,
			&i.IntentWithInputsVw.Swept,
			&i.IntentWithInputsVw.Preconfirmed,
			&i.IntentWithInputsVw.SettledBy,
			&i.IntentWithInputsVw.ArkTxid,
			&i.IntentWithInputsVw.IntentID,
			&i.IntentWithInputsVw.Commitments,
			&i.IntentWithInputsVw.ID,
			&i.IntentWithInputsVw.RoundID,
			&i.IntentWithInputsVw.Proof,
			&i.IntentWithInputsVw.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundsWithTxids = `-- name: SelectRoundsWithTxids :many
SELECT txid FROM tx WHERE type = 'commitment' AND tx.txid = ANY($1::varchar[])
`

func (q *Queries) SelectRoundsWithTxids(ctx context.Context, dollar_1 []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundsWithTxids, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableRounds = `-- name: SelectSweepableRounds :many
SELECT txid FROM round_with_commitment_tx_vw r WHERE r.swept = false AND r.ended = true AND r.failed = false
`

func (q *Queries) SelectSweepableRounds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableRounds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableVtxos = `-- name: SelectSweepableVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE unrolled = false AND swept = false
`

type SelectSweepableVtxosRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectSweepableVtxos(ctx context.Context) ([]SelectSweepableVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableVtxosRow
	for rows.Next() {
		var i SelectSweepableVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweptRoundsConnectorAddress = `-- name: SelectSweptRoundsConnectorAddress :many
SELECT round.connector_address FROM round
WHERE round.swept = true AND round.failed = false AND round.ended = true AND round.connector_address <> ''
`

func (q *Queries) SelectSweptRoundsConnectorAddress(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweptRoundsConnectorAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var connector_address string
		if err := rows.Scan(&connector_address); err != nil {
			return nil, err
		}
		items = append(items, connector_address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTxs = `-- name: SelectTxs :many
SELECT tx.txid, tx.tx AS data FROM tx WHERE tx.txid = ANY($1::varchar[])
UNION
SELECT offchain_tx.txid, offchain_tx.tx AS data FROM offchain_tx WHERE offchain_tx.txid = ANY($1::varchar[])
UNION
SELECT checkpoint_tx.txid, checkpoint_tx.tx AS data FROM checkpoint_tx WHERE checkpoint_tx.txid = ANY($1::varchar[])
`

type SelectTxsRow struct {
	Txid string
	Data string
}

func (q *Queries) SelectTxs(ctx context.Context, dollar_1 []string) ([]SelectTxsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectTxs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectTxsRow
	for rows.Next() {
		var i SelectTxsRow
		if err := rows.Scan(&i.Txid, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxo = `-- name: SelectVtxo :one
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE txid = $1 AND vout = $2
`

type SelectVtxoParams struct {
	Txid string
	Vout int32
}

type SelectVtxoRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectVtxo(ctx context.Context, arg SelectVtxoParams) (SelectVtxoRow, error) {
	row := q.db.QueryRowContext(ctx, selectVtxo, arg.Txid, arg.Vout)
	var i SelectVtxoRow
	err := row.Scan(
		&i.VtxoVw.Txid,
		&i.VtxoVw.Vout,
		&i.VtxoVw.Pubkey,
		&i.VtxoVw.Amount,
		&i.VtxoVw.ExpiresAt,
		&i.VtxoVw.CreatedAt,
		&i.VtxoVw.CommitmentTxid,
		&i.VtxoVw.SpentBy,
		&i.VtxoVw.Spent,
		&i.VtxoVw.Unrolled,
		&i.VtxoVw.Swept,
		&i.VtxoVw.Preconfirmed,
		&i.VtxoVw.SettledBy,
		&i.VtxoVw.ArkTxid,
		&i.VtxoVw.IntentID,
		&i.VtxoVw.Commitments,
	)
	return i, err
}

const selectVtxosWithCommitmentTxid = `-- name: SelectVtxosWithCommitmentTxid :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE commitment_txid = $1
`

type SelectVtxosWithCommitmentTxidRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectVtxosWithCommitmentTxid(ctx context.Context, commitmentTxid string) ([]SelectVtxosWithCommitmentTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosWithCommitmentTxid, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosWithCommitmentTxidRow
	for rows.Next() {
		var i SelectVtxosWithCommitmentTxidRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosWithPubkeys = `-- name: SelectVtxosWithPubkeys :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE pubkey = ANY($1::varchar[])
`

type SelectVtxosWithPubkeysRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectVtxosWithPubkeys(ctx context.Context, dollar_1 []string) ([]SelectVtxosWithPubkeysRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosWithPubkeys, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosWithPubkeysRow
	for rows.Next() {
		var i SelectVtxosWithPubkeysRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVtxoExpiration = `-- name: UpdateVtxoExpiration :exec
UPDATE vtxo SET expires_at = $1 WHERE txid = $2 AND vout = $3
`

type UpdateVtxoExpirationParams struct {
	ExpiresAt int64
	Txid      string
	Vout      int32
}

func (q *Queries) UpdateVtxoExpiration(ctx context.Context, arg UpdateVtxoExpirationParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoExpiration, arg.ExpiresAt, arg.Txid, arg.Vout)
	return err
}

const updateVtxoIntentId = `-- name: UpdateVtxoIntentId :exec
UPDATE vtxo SET intent_id = $1 WHERE txid = $2 AND vout = $3
`

type UpdateVtxoIntentIdParams struct {
	IntentID sql.NullString
	Txid     string
	Vout     int32
}

func (q *Queries) UpdateVtxoIntentId(ctx context.Context, arg UpdateVtxoIntentIdParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoIntentId, arg.IntentID, arg.Txid, arg.Vout)
	return err
}

const updateVtxoSettled = `-- name: UpdateVtxoSettled :exec
UPDATE vtxo SET spent = true, spent_by = $1, settled_by = $2
WHERE txid = $3 AND vout = $4
`

type UpdateVtxoSettledParams struct {
	SpentBy   sql.NullString
	SettledBy sql.NullString
	Txid      string
	Vout      int32
}

func (q *Queries) UpdateVtxoSettled(ctx context.Context, arg UpdateVtxoSettledParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoSettled,
		arg.SpentBy,
		arg.SettledBy,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const updateVtxoSpent = `-- name: UpdateVtxoSpent :exec
UPDATE vtxo SET spent = true, spent_by = $1, ark_txid = $2
WHERE txid = $3 AND vout = $4
`

type UpdateVtxoSpentParams struct {
	SpentBy sql.NullString
	ArkTxid sql.NullString
	Txid    string
	Vout    int32
}

func (q *Queries) UpdateVtxoSpent(ctx context.Context, arg UpdateVtxoSpentParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoSpent,
		arg.SpentBy,
		arg.ArkTxid,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const updateVtxoSwept = `-- name: UpdateVtxoSwept :exec
UPDATE vtxo SET swept = true WHERE txid = $1 AND vout = $2
`

type UpdateVtxoSweptParams struct {
	Txid string
	Vout int32
}

func (q *Queries) UpdateVtxoSwept(ctx context.Context, arg UpdateVtxoSweptParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoSwept, arg.Txid, arg.Vout)
	return err
}

const updateVtxoUnrolled = `-- name: UpdateVtxoUnrolled :exec
UPDATE vtxo SET unrolled = true WHERE txid = $1 AND vout = $2
`

type UpdateVtxoUnrolledParams struct {
	Txid string
	Vout int32
}

func (q *Queries) UpdateVtxoUnrolled(ctx context.Context, arg UpdateVtxoUnrolledParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoUnrolled, arg.Txid, arg.Vout)
	return err
}

const upsertCheckpointTx = `-- name: UpsertCheckpointTx :exec
INSERT INTO checkpoint_tx (txid, tx, commitment_txid, is_root_commitment_txid, offchain_txid)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    commitment_txid = EXCLUDED.commitment_txid,
    is_root_commitment_txid = EXCLUDED.is_root_commitment_txid,
    offchain_txid = EXCLUDED.offchain_txid
`

type UpsertCheckpointTxParams struct {
	Txid                 string
	Tx                   string
	CommitmentTxid       string
	IsRootCommitmentTxid bool
	OffchainTxid         string
}

func (q *Queries) UpsertCheckpointTx(ctx context.Context, arg UpsertCheckpointTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertCheckpointTx,
		arg.Txid,
		arg.Tx,
		arg.CommitmentTxid,
		arg.IsRootCommitmentTxid,
		arg.OffchainTxid,
	)
	return err
}

const upsertIntent = `-- name: UpsertIntent :exec
INSERT INTO intent (id, round_id, proof, message) VALUES ($1, $2, $3, $4)
ON CONFLICT(id) DO UPDATE SET
    round_id = EXCLUDED.round_id,
    proof = EXCLUDED.proof,
    message = EXCLUDED.message
`

type UpsertIntentParams struct {
	ID      sql.NullString
	RoundID sql.NullString
	Proof   sql.NullString
	Message sql.NullString
}

func (q *Queries) UpsertIntent(ctx context.Context, arg UpsertIntentParams) error {
	_, err := q.db.ExecContext(ctx, upsertIntent,
		arg.ID,
		arg.RoundID,
		arg.Proof,
		arg.Message,
	)
	return err
}

const upsertMarketHour = `-- name: UpsertMarketHour :exec
INSERT INTO market_hour (id, start_time, end_time, period, round_interval, updated_at)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (id) DO UPDATE SET
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    period = EXCLUDED.period,
    round_interval = EXCLUDED.round_interval,
    updated_at = EXCLUDED.updated_at
`

type UpsertMarketHourParams struct {
	ID            int32
	StartTime     int64
	EndTime       int64
	Period        int64
	RoundInterval int64
	UpdatedAt     int64
}

func (q *Queries) UpsertMarketHour(ctx context.Context, arg UpsertMarketHourParams) error {
	_, err := q.db.ExecContext(ctx, upsertMarketHour,
		arg.ID,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.RoundInterval,
		arg.UpdatedAt,
	)
	return err
}

const upsertOffchainTx = `-- name: UpsertOffchainTx :exec
INSERT INTO offchain_tx (txid, tx, starting_timestamp, ending_timestamp, expiry_timestamp, fail_reason, stage_code)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    expiry_timestamp = EXCLUDED.expiry_timestamp,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code
`

type UpsertOffchainTxParams struct {
	Txid              string
	Tx                string
	StartingTimestamp int64
	EndingTimestamp   int64
	ExpiryTimestamp   int64
	FailReason        sql.NullString
	StageCode         int32
}

func (q *Queries) UpsertOffchainTx(ctx context.Context, arg UpsertOffchainTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertOffchainTx,
		arg.Txid,
		arg.Tx,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.ExpiryTimestamp,
		arg.FailReason,
		arg.StageCode,
	)
	return err
}

const upsertReceiver = `-- name: UpsertReceiver :exec
INSERT INTO receiver (intent_id, pubkey, onchain_address, amount)
VALUES ($1, $2, $3, $4)
ON CONFLICT(intent_id, pubkey, onchain_address) DO UPDATE SET
    amount = EXCLUDED.amount,
    pubkey = EXCLUDED.pubkey,
    onchain_address = EXCLUDED.onchain_address
`

type UpsertReceiverParams struct {
	IntentID       string
	Pubkey         string
	OnchainAddress string
	Amount         int64
}

func (q *Queries) UpsertReceiver(ctx context.Context, arg UpsertReceiverParams) error {
	_, err := q.db.ExecContext(ctx, upsertReceiver,
		arg.IntentID,
		arg.Pubkey,
		arg.OnchainAddress,
		arg.Amount,
	)
	return err
}

const upsertRound = `-- name: UpsertRound :exec
INSERT INTO round (
    id, starting_timestamp, ending_timestamp, ended, failed, fail_reason,
    stage_code, connector_address, version, swept, vtxo_tree_expiration
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11
)
ON CONFLICT(id) DO UPDATE SET
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    ended = EXCLUDED.ended,
    failed = EXCLUDED.failed,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code,
    connector_address = EXCLUDED.connector_address,
    version = EXCLUDED.version,
    swept = EXCLUDED.swept,
    vtxo_tree_expiration = EXCLUDED.vtxo_tree_expiration
`

type UpsertRoundParams struct {
	ID                 string
	StartingTimestamp  int64
	EndingTimestamp    int64
	Ended              bool
	Failed             bool
	FailReason         sql.NullString
	StageCode          int32
	ConnectorAddress   string
	Version            int32
	Swept              bool
	VtxoTreeExpiration int64
}

func (q *Queries) UpsertRound(ctx context.Context, arg UpsertRoundParams) error {
	_, err := q.db.ExecContext(ctx, upsertRound,
		arg.ID,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.Ended,
		arg.Failed,
		arg.FailReason,
		arg.StageCode,
		arg.ConnectorAddress,
		arg.Version,
		arg.Swept,
		arg.VtxoTreeExpiration,
	)
	return err
}

const upsertTx = `-- name: UpsertTx :exec
INSERT INTO tx (tx, round_id, type, position, txid, children)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    round_id = EXCLUDED.round_id,
    type = EXCLUDED.type,
    position = EXCLUDED.position,
    txid = EXCLUDED.txid,
    children = EXCLUDED.children
`

type UpsertTxParams struct {
	Tx       string
	RoundID  string
	Type     string
	Position int32
	Txid     string
	Children pqtype.NullRawMessage
}

func (q *Queries) UpsertTx(ctx context.Context, arg UpsertTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertTx,
		arg.Tx,
		arg.RoundID,
		arg.Type,
		arg.Position,
		arg.Txid,
		arg.Children,
	)
	return err
}

const upsertVtxo = `-- name: UpsertVtxo :exec
INSERT INTO vtxo (
    txid, vout, pubkey, amount, commitment_txid, settled_by, ark_txid,
    spent_by, spent, unrolled, swept, preconfirmed, expires_at, created_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13, $14
) ON CONFLICT(txid, vout) DO UPDATE SET
    pubkey = EXCLUDED.pubkey,
    amount = EXCLUDED.amount,
    commitment_txid = EXCLUDED.commitment_txid,
    settled_by = EXCLUDED.settled_by,
    ark_txid = EXCLUDED.ark_txid,
    spent_by = EXCLUDED.spent_by,
    spent = EXCLUDED.spent,
    unrolled = EXCLUDED.unrolled,
    swept = EXCLUDED.swept,
    preconfirmed = EXCLUDED.preconfirmed,
    expires_at = EXCLUDED.expires_at,
    created_at = EXCLUDED.created_at
`

type UpsertVtxoParams struct {
	Txid           string
	Vout           int32
	Pubkey         string
	Amount         int64
	CommitmentTxid string
	SettledBy      sql.NullString
	ArkTxid        sql.NullString
	SpentBy        sql.NullString
	Spent          bool
	Unrolled       bool
	Swept          bool
	Preconfirmed   bool
	ExpiresAt      int64
	CreatedAt      int64
}

func (q *Queries) UpsertVtxo(ctx context.Context, arg UpsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Pubkey,
		arg.Amount,
		arg.CommitmentTxid,
		arg.SettledBy,
		arg.ArkTxid,
		arg.SpentBy,
		arg.Spent,
		arg.Unrolled,
		arg.Swept,
		arg.Preconfirmed,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}
