// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const cleanTxs = `-- name: CleanTxs :exec
DELETE FROM tx
`

func (q *Queries) CleanTxs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanTxs)
	return err
}

const cleanVtxos = `-- name: CleanVtxos :exec
DELETE FROM vtxo
`

func (q *Queries) CleanVtxos(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanVtxos)
	return err
}

const insertTx = `-- name: InsertTx :exec
INSERT INTO tx (
    txid, txid_type, amount, type, settled, created_at, hex, settled_by
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertTxParams struct {
	Txid      string
	TxidType  string
	Amount    int64
	Type      string
	Settled   bool
	CreatedAt int64
	Hex       sql.NullString
	SettledBy sql.NullString
}

func (q *Queries) InsertTx(ctx context.Context, arg InsertTxParams) error {
	_, err := q.db.ExecContext(ctx, insertTx,
		arg.Txid,
		arg.TxidType,
		arg.Amount,
		arg.Type,
		arg.Settled,
		arg.CreatedAt,
		arg.Hex,
		arg.SettledBy,
	)
	return err
}

const insertVtxo = `-- name: InsertVtxo :exec
INSERT INTO vtxo (
    txid, vout, script, amount, commitment_txids, spent_by, spent, preconfirmed, expires_at, created_at, swept, unrolled, settled_by, ark_txid
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertVtxoParams struct {
	Txid            string
	Vout            int64
	Script          string
	Amount          int64
	CommitmentTxids string
	SpentBy         sql.NullString
	Spent           bool
	Preconfirmed    bool
	ExpiresAt       int64
	CreatedAt       int64
	Swept           bool
	Unrolled        bool
	SettledBy       sql.NullString
	ArkTxid         sql.NullString
}

func (q *Queries) InsertVtxo(ctx context.Context, arg InsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, insertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Script,
		arg.Amount,
		arg.CommitmentTxids,
		arg.SpentBy,
		arg.Spent,
		arg.Preconfirmed,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.Swept,
		arg.Unrolled,
		arg.SettledBy,
		arg.ArkTxid,
	)
	return err
}

const replaceTx = `-- name: ReplaceTx :exec
UPDATE tx
SET    txid       = ?1,
       txid_type  = ?2,
       amount     = ?3,
       type       = ?4,
       settled    = ?5,
       settled_by    = ?6,
       created_at = ?7,
       hex        = ?8
WHERE  txid = ?9
`

type ReplaceTxParams struct {
	NewTxid   string
	TxidType  string
	Amount    int64
	Type      string
	Settled   bool
	SettledBy sql.NullString
	CreatedAt int64
	Hex       sql.NullString
	OldTxid   string
}

func (q *Queries) ReplaceTx(ctx context.Context, arg ReplaceTxParams) error {
	_, err := q.db.ExecContext(ctx, replaceTx,
		arg.NewTxid,
		arg.TxidType,
		arg.Amount,
		arg.Type,
		arg.Settled,
		arg.SettledBy,
		arg.CreatedAt,
		arg.Hex,
		arg.OldTxid,
	)
	return err
}

const selectAllTxs = `-- name: SelectAllTxs :many
SELECT txid, txid_type, amount, type, settled, created_at, hex, settled_by FROM tx
`

func (q *Queries) SelectAllTxs(ctx context.Context) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectAllTxs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.TxidType,
			&i.Amount,
			&i.Type,
			&i.Settled,
			&i.CreatedAt,
			&i.Hex,
			&i.SettledBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllVtxos = `-- name: SelectAllVtxos :many
SELECT txid, vout, script, amount, commitment_txids, spent_by, spent, expires_at, created_at, preconfirmed, swept, settled_by, unrolled, ark_txid from vtxo
`

func (q *Queries) SelectAllVtxos(ctx context.Context) ([]Vtxo, error) {
	rows, err := q.db.QueryContext(ctx, selectAllVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vtxo
	for rows.Next() {
		var i Vtxo
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Script,
			&i.Amount,
			&i.CommitmentTxids,
			&i.SpentBy,
			&i.Spent,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.Preconfirmed,
			&i.Swept,
			&i.SettledBy,
			&i.Unrolled,
			&i.ArkTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTxs = `-- name: SelectTxs :many
SELECT txid, txid_type, amount, type, settled, created_at, hex, settled_by FROM tx
WHERE txid IN (/*SLICE:txids*/?)
`

func (q *Queries) SelectTxs(ctx context.Context, txids []string) ([]Tx, error) {
	query := selectTxs
	var queryParams []interface{}
	if len(txids) > 0 {
		for _, v := range txids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:txids*/?", strings.Repeat(",?", len(txids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:txids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.TxidType,
			&i.Amount,
			&i.Type,
			&i.Settled,
			&i.CreatedAt,
			&i.Hex,
			&i.SettledBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxo = `-- name: SelectVtxo :one
SELECT txid, vout, script, amount, commitment_txids, spent_by, spent, expires_at, created_at, preconfirmed, swept, settled_by, unrolled, ark_txid
FROM vtxo
WHERE txid = ?1 AND vout = ?2
`

type SelectVtxoParams struct {
	Txid string
	Vout int64
}

func (q *Queries) SelectVtxo(ctx context.Context, arg SelectVtxoParams) (Vtxo, error) {
	row := q.db.QueryRowContext(ctx, selectVtxo, arg.Txid, arg.Vout)
	var i Vtxo
	err := row.Scan(
		&i.Txid,
		&i.Vout,
		&i.Script,
		&i.Amount,
		&i.CommitmentTxids,
		&i.SpentBy,
		&i.Spent,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Preconfirmed,
		&i.Swept,
		&i.SettledBy,
		&i.Unrolled,
		&i.ArkTxid,
	)
	return i, err
}

const updateTx = `-- name: UpdateTx :exec
UPDATE tx
SET
    created_at     = COALESCE(?1,     created_at),
    settled    = COALESCE(?2,    settled),
    settled_by    = COALESCE(?3,    settled_by)
WHERE txid = ?4
`

type UpdateTxParams struct {
	CreatedAt sql.NullInt64
	Settled   sql.NullBool
	SettledBy sql.NullString
	Txid      string
}

func (q *Queries) UpdateTx(ctx context.Context, arg UpdateTxParams) error {
	_, err := q.db.ExecContext(ctx, updateTx,
		arg.CreatedAt,
		arg.Settled,
		arg.SettledBy,
		arg.Txid,
	)
	return err
}

const updateVtxo = `-- name: UpdateVtxo :exec
UPDATE vtxo
SET
    spent = true,
    spent_by = ?1,
    settled_by = ?2,
    ark_txid = ?3
WHERE txid = ?4 AND vout = ?5
`

type UpdateVtxoParams struct {
	SpentBy   sql.NullString
	SettledBy sql.NullString
	ArkTxid   sql.NullString
	Txid      string
	Vout      int64
}

func (q *Queries) UpdateVtxo(ctx context.Context, arg UpdateVtxoParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxo,
		arg.SpentBy,
		arg.SettledBy,
		arg.ArkTxid,
		arg.Txid,
		arg.Vout,
	)
	return err
}
